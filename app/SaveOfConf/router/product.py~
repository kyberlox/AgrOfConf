import os
import aiofiles
from fastapi import APIRouter, Depends, HTTPException, UploadFile, File, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from ..model.database import get_db, create_tables
from ..model.product import Product as ProductModel
from ..schema.product import ProductCreate, ProductUpdate, Product
from typing import List

router = APIRouter(prefix="/products", tags=["products"])


# Создаем таблицы при старте (в реальном приложении лучше использовать миграции)
@router.on_event("startup")
async def startup_event():
    await create_tables()


@router.post("/", response_model=Product, status_code=status.HTTP_201_CREATED)
async def create_product(
        product_data: ProductCreate,
        db: AsyncSession = Depends(get_db)
):
    db_product = ProductModel(**product_data.dict())
    db.add(db_product)
    await db.commit()
    await db.refresh(db_product)
    return db_product


@router.get("/", response_model=List[Product])
async def read_products(
        skip: int = 0,
        limit: int = 100,
        db: AsyncSession = Depends(get_db)
):
    result = await db.execute(select(ProductModel).offset(skip).limit(limit))
    products = result.scalars().all()
    return products


@router.get("/{product_id}", response_model=Product)
async def read_product(product_id: int, db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(ProductModel).filter(ProductModel.id == product_id))
    db_product = result.scalar_one_or_none()

    if not db_product:
        raise HTTPException(status_code=404, detail="Product not found")
    return db_product


@router.put("/{product_id}", response_model=Product)
async def update_product(
        product_id: int,
        product_data: ProductUpdate,
        db: AsyncSession = Depends(get_db)
):
    result = await db.execute(select(ProductModel).filter(ProductModel.id == product_id))
    db_product = result.scalar_one_or_none()

    if not db_product:
        raise HTTPException(status_code=404, detail="Product not found")

    for field, value in product_data.dict(exclude_unset=True).items():
        setattr(db_product, field, value)

    await db.commit()
    await db.refresh(db_product)
    return db_product


@router.delete("/{product_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_product(product_id: int, db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(ProductModel).filter(ProductModel.id == product_id))
    db_product = result.scalar_one_or_none()

    if not db_product:
        raise HTTPException(status_code=404, detail="Product not found")

    await db.delete(db_product)
    await db.commit()
    return None


@router.post("/{product_id}/image", response_model=Product)
async def set_product_image(
        product_id: int,
        file: UploadFile = File(...),
        db: AsyncSession = Depends(get_db)
):
    # Проверяем существование продукта
    result = await db.execute(select(ProductModel).filter(ProductModel.id == product_id))
    db_product = result.scalar_one_or_none()

    if not db_product:
        raise HTTPException(status_code=404, detail="Product not found")

    # Создаем папку static если не существует
    os.makedirs("app/static", exist_ok=True)

    # Генерируем безопасное имя файла
    file_extension = os.path.splitext(file.filename)[1]
    filename = f"product_{product_id}{file_extension}"
    file_path = os.path.join("app/static", filename)

    # Асинхронно сохраняем файл
    async with aiofiles.open(file_path, "wb") as f:
        content = await file.read()
        await f.write(content)

    # Обновляем путь к изображению в БД
    db_product.image = f"/static/{filename}"
    await db.commit()
    await db.refresh(db_product)

    return db_product